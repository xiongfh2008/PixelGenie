// å›¾åƒç¼–è¾‘ API é›†æˆ
// æ”¯æŒçœŸæ­£çš„å›¾åƒç”Ÿæˆå’Œç¼–è¾‘åŠŸèƒ½

import fetch from 'node-fetch';
import FormData from 'form-data';
import { Buffer } from 'buffer';

/**
 * Replicate API - æ”¯æŒå¤šç§å›¾åƒç¼–è¾‘æ¨¡åž‹
 * å…è´¹é¢åº¦ï¼šæ¯æœˆ $5 å…è´¹é¢åº¦
 * æ¨¡åž‹ï¼šLaMa (åŽ»æ°´å°)ã€Stable Diffusion Inpainting
 */
export const replicateImageEdit = async (imageBase64, prompt, apiKey) => {
  try {
    // ä½¿ç”¨ LaMa æ¨¡åž‹è¿›è¡Œå›¾åƒä¿®å¤ï¼ˆåŽ»æ°´å°ï¼‰
    const response = await fetch('https://api.replicate.com/v1/predictions', {
      method: 'POST',
      headers: {
        'Authorization': `Token ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        version: 'e35c0e4e8a8c6f0e3c0b0f0e3c0b0f0e3c0b0f0e3c0b0f0e3c0b0f0e3c0b0f0e', // LaMa æ¨¡åž‹
        input: {
          image: `data:image/jpeg;base64,${imageBase64}`,
          prompt: prompt
        }
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Replicate API error: ${errorData.detail || response.statusText}`);
    }

    const prediction = await response.json();
    
    // è½®è¯¢ç»“æžœ
    let result = prediction;
    while (result.status === 'starting' || result.status === 'processing') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      const statusResponse = await fetch(`https://api.replicate.com/v1/predictions/${result.id}`, {
        headers: {
          'Authorization': `Token ${apiKey}`
        }
      });
      result = await statusResponse.json();
    }

    if (result.status === 'succeeded' && result.output) {
      // è¿”å›žå›¾åƒ URL æˆ– base64
      return {
        success: true,
        imageUrl: result.output,
        provider: 'replicate'
      };
    } else {
      throw new Error(`Replicate prediction failed: ${result.error || 'Unknown error'}`);
    }
  } catch (error) {
    console.error('Replicate API error:', error);
    throw error;
  }
};

/**
 * Stability AI - Stable Diffusion Inpainting
 * å…è´¹è¯•ç”¨ï¼š25 ç§¯åˆ†
 * åŠŸèƒ½ï¼šå›¾åƒä¿®å¤ã€åŽ»æ°´å°ã€å¯¹è±¡ç§»é™¤
 */
export const stabilityImageEdit = async (imageBase64, maskBase64, prompt, apiKey) => {
  try {
    const formData = new FormData();
    
    // Convert base64 to buffer
    const imageBuffer = Buffer.from(imageBase64, 'base64');
    formData.append('init_image', imageBuffer, {
      filename: 'image.jpg',
      contentType: 'image/jpeg'
    });
    
    if (maskBase64) {
      const maskBuffer = Buffer.from(maskBase64, 'base64');
      formData.append('mask_image', maskBuffer, {
        filename: 'mask.jpg',
        contentType: 'image/jpeg'
      });
    }
    
    formData.append('text_prompts[0][text]', prompt);
    formData.append('text_prompts[0][weight]', '1');
    formData.append('cfg_scale', '7');
    formData.append('samples', '1');
    formData.append('steps', '30');

    const response = await fetch('https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/image-to-image/masking', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Accept': 'application/json',
        ...formData.getHeaders()
      },
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Stability AI error: ${errorData.message || response.statusText}`);
    }

    const result = await response.json();
    
    if (result.artifacts && result.artifacts.length > 0) {
      return {
        success: true,
        imageData: result.artifacts[0].base64,
        provider: 'stability'
      };
    } else {
      throw new Error('No image generated by Stability AI');
    }
  } catch (error) {
    console.error('Stability AI error:', error);
    throw error;
  }
};

/**
 * ClipDrop API - ä¸“ä¸šçš„å›¾åƒç¼–è¾‘å·¥å…·
 * å…è´¹é¢åº¦ï¼šæ¯æœˆ 100 æ¬¡è¯·æ±‚
 * åŠŸèƒ½ï¼šåŽ»èƒŒæ™¯ã€åŽ»æ°´å°ã€å›¾åƒå¢žå¼º
 */
export const clipdropRemoveObject = async (imageBase64, apiKey) => {
  try {
    const formData = new FormData();
    
    // å°† base64 è½¬æ¢ä¸º Buffer
    const imageBuffer = Buffer.from(imageBase64, 'base64');
    formData.append('image_file', imageBuffer, {
      filename: 'image.jpg',
      contentType: 'image/jpeg'
    });

    const response = await fetch('https://clipdrop-api.co/cleanup/v1', {
      method: 'POST',
      headers: {
        'x-api-key': apiKey,
        ...formData.getHeaders()
      },
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`ClipDrop API error: ${errorText || response.statusText}`);
    }

    const resultBuffer = await response.arrayBuffer();
    const resultBase64 = Buffer.from(resultBuffer).toString('base64');

    return {
      success: true,
      imageData: resultBase64,
      provider: 'clipdrop'
    };
  } catch (error) {
    console.error('ClipDrop API error:', error);
    throw error;
  }
};

/**
 * Remove.bg API - ä¸“ä¸šçš„èƒŒæ™¯ç§»é™¤å’Œå¯¹è±¡ç§»é™¤
 * å…è´¹é¢åº¦ï¼šæ¯æœˆ 50 æ¬¡è¯·æ±‚
 * åŠŸèƒ½ï¼šåŽ»èƒŒæ™¯ã€åŽ»æ°´å°
 */
export const removebgRemoveObject = async (imageBase64, apiKey) => {
  try {
    const formData = new FormData();
    formData.append('image_file_b64', imageBase64);
    formData.append('size', 'auto');

    const response = await fetch('https://api.remove.bg/v1.0/removebg', {
      method: 'POST',
      headers: {
        'X-Api-Key': apiKey,
        ...formData.getHeaders()
      },
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Remove.bg API error: ${errorData.errors?.[0]?.title || response.statusText}`);
    }

    const resultBuffer = await response.arrayBuffer();
    const resultBase64 = Buffer.from(resultBuffer).toString('base64');

    return {
      success: true,
      imageData: resultBase64,
      provider: 'removebg'
    };
  } catch (error) {
    console.error('Remove.bg API error:', error);
    throw error;
  }
};

/**
 * HuggingFace Inference API - ä½¿ç”¨çœŸæ­£çš„å›¾åƒç¼–è¾‘æ¨¡åž‹
 * å…è´¹é¢åº¦ï¼šæœ‰é™åˆ¶ä½†å¯ç”¨
 * æ¨¡åž‹ï¼šStable Diffusion Inpainting, LaMa
 */
export const huggingfaceImageInpainting = async (imageBase64, prompt, apiKey) => {
  try {
    // ä½¿ç”¨ Stable Diffusion Inpainting æ¨¡åž‹
    const response = await fetch(
      'https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-2-inpainting',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          inputs: {
            image: imageBase64,
            prompt: prompt
          },
          parameters: {
            negative_prompt: 'watermark, text, logo, signature',
            num_inference_steps: 50,
            guidance_scale: 7.5
          }
        })
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HuggingFace API error: ${errorText || response.statusText}`);
    }

    // HuggingFace è¿”å›žçš„æ˜¯å›¾åƒäºŒè¿›åˆ¶æ•°æ®
    const resultBuffer = await response.arrayBuffer();
    const resultBase64 = Buffer.from(resultBuffer).toString('base64');

    return {
      success: true,
      imageData: resultBase64,
      provider: 'huggingface-inpainting'
    };
  } catch (error) {
    console.error('HuggingFace Inpainting error:', error);
    throw error;
  }
};

/**
 * æ™ºèƒ½é€‰æ‹©æœ€ä½³å›¾åƒç¼–è¾‘ API
 */
export const selectImageEditingApi = (apiKeys) => {
  const providers = [];

  if (apiKeys.replicate) providers.push('replicate');
  if (apiKeys.stability) providers.push('stability');
  if (apiKeys.clipdrop) providers.push('clipdrop');
  if (apiKeys.removebg) providers.push('removebg');
  if (apiKeys.huggingface) providers.push('huggingface-inpainting');

  if (providers.length === 0) {
    throw new Error('No image editing API configured. Please add at least one API key.');
  }

  // ä¼˜å…ˆçº§ï¼šClipDrop > Remove.bg > Replicate > Stability > HuggingFace
  const priority = ['clipdrop', 'removebg', 'replicate', 'stability', 'huggingface-inpainting'];
  
  for (const provider of priority) {
    if (providers.includes(provider)) {
      return provider;
    }
  }

  return providers[0];
};

/**
 * ç»Ÿä¸€çš„å›¾åƒç¼–è¾‘æŽ¥å£
 */
export const editImageWithBestApi = async (imageBase64, prompt, apiKeys, maskBase64 = null) => {
  const provider = selectImageEditingApi(apiKeys);
  
  console.log(`ðŸŽ¨ Using ${provider} for image editing`);

  try {
    switch (provider) {
      case 'replicate':
        return await replicateImageEdit(imageBase64, prompt, apiKeys.replicate);
      
      case 'stability':
        return await stabilityImageEdit(imageBase64, maskBase64, prompt, apiKeys.stability);
      
      case 'clipdrop':
        return await clipdropRemoveObject(imageBase64, apiKeys.clipdrop);
      
      case 'removebg':
        return await removebgRemoveObject(imageBase64, apiKeys.removebg);
      
      case 'huggingface-inpainting':
        return await huggingfaceImageInpainting(imageBase64, prompt, apiKeys.huggingface);
      
      default:
        throw new Error(`Unsupported image editing provider: ${provider}`);
    }
  } catch (error) {
    console.error(`âŒ ${provider} failed:`, error.message);
    
    // å°è¯•ä¸‹ä¸€ä¸ªå¯ç”¨çš„ API
    const allProviders = ['clipdrop', 'removebg', 'replicate', 'stability', 'huggingface-inpainting'];
    const remainingProviders = allProviders.filter(p => p !== provider && apiKeys[p]);
    
    if (remainingProviders.length > 0) {
      console.log(`ðŸ”„ Trying fallback provider: ${remainingProviders[0]}`);
      
      // æ›´æ–° apiKeys å¯¹è±¡ï¼Œç§»é™¤å¤±è´¥çš„ provider
      const fallbackKeys = { ...apiKeys };
      delete fallbackKeys[provider];
      
      return await editImageWithBestApi(imageBase64, prompt, fallbackKeys, maskBase64);
    }
    
    throw error;
  }
};

